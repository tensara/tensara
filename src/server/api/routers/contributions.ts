import { createTRPCRouter, protectedProcedure } from "~/server/api/trpc";
import { z } from "zod";
import { TRPCError } from "@trpc/server";
import { Octokit } from "@octokit/rest";
import {
  createBranch,
  createOrUpdateFile,
  createPullRequest,
  getFileContent,
  listPullRequests,
  getOctokitInstance, // Add this
} from "../../github";

const ProblemMetadataSchema = z.object({
  title: z.string(),
  difficulty: z.union([
    z.literal("EASY"),
    z.literal("MEDIUM"),
    z.literal("HARD"),
    z.literal("EXPERT"),
  ]),
  tags: z.array(z.string()),
  tensaraAppUserId: z.string().optional(),
});

const GITHUB_REPO_OWNER = "tensara";
const GITHUB_REPO_NAME = "problems";
const GITHUB_BASE_BRANCH = "main";

export const contributionsRouter = createTRPCRouter({
  submitNewProblem: protectedProcedure
    .input(
      z.object({
        contributorGithubUsername: z.string(),
        tensaraAppUserId: z.string(),
        problemDetails: z.object({
          title: z.string(),
          slug: z.string(), // Generated by frontend or backend
          description: z.string(),
          difficulty: z.enum(["EASY", "MEDIUM", "HARD", "EXPERT"]),
          tags: z.array(z.string()),
          referenceCode: z.string(),
          testCases: z.string(),
        }),
      })
    )
    .mutation(async ({ input, ctx }) => {
      if (!ctx.session.user) {
        throw new TRPCError({
          code: "UNAUTHORIZED",
          message: "You must be logged in to submit a problem",
        });
      }

      const newBranchName = `new-problem-${input.problemDetails.slug}-${Date.now()}`;
      const problemDirPath = `problems/${input.problemDetails.slug}/`;

      try {
        await createBranch(
          GITHUB_REPO_OWNER,
          GITHUB_REPO_NAME,
          GITHUB_BASE_BRANCH,
          newBranchName
        );

        // Create problem.md
        await createOrUpdateFile(
          GITHUB_REPO_OWNER,
          GITHUB_REPO_NAME,
          newBranchName,
          `${problemDirPath}problem.md`,
          input.problemDetails.description,
          `feat: Add problem.md for ${input.problemDetails.slug}`
        );

        // Create reference.cu
        await createOrUpdateFile(
          GITHUB_REPO_OWNER,
          GITHUB_REPO_NAME,
          newBranchName,
          `${problemDirPath}reference.cu`,
          input.problemDetails.referenceCode,
          `feat: Add reference.cu for ${input.problemDetails.slug}`
        );

        // Create tests.hpp
        await createOrUpdateFile(
          GITHUB_REPO_OWNER,
          GITHUB_REPO_NAME,
          newBranchName,
          `${problemDirPath}tests.hpp`,
          input.problemDetails.testCases,
          `feat: Add tests.hpp for ${input.problemDetails.slug}`
        );

        // Create metadata.json
        const metadataContent = JSON.stringify(
          {
            title: input.problemDetails.title,
            difficulty: input.problemDetails.difficulty,
            tags: input.problemDetails.tags,
            tensaraAppUserId: input.tensaraAppUserId,
          },
          null,
          2
        );
        await createOrUpdateFile(
          GITHUB_REPO_OWNER,
          GITHUB_REPO_NAME,
          newBranchName,
          `${problemDirPath}metadata.json`,
          metadataContent,
          `feat: Add metadata.json for ${input.problemDetails.slug}`
        );

        const prTitle = `feat: New Problem: ${input.problemDetails.title} (${input.problemDetails.slug})`;
        const prBody = `This PR introduces a new problem: "${input.problemDetails.title}".\n\nSubmitted by Tensara App User ID: ${input.tensaraAppUserId}\nContributor GitHub Username: ${input.contributorGithubUsername}`;

        const prUrl = await createPullRequest(
          GITHUB_REPO_OWNER,
          GITHUB_REPO_NAME,
          newBranchName,
          GITHUB_BASE_BRANCH,
          prTitle,
          prBody
        );

        return { prUrl };
      } catch (error) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message:
            error instanceof Error
              ? `Failed to submit new problem: ${error.message}`
              : "Failed to submit new problem",
        });
      }
    }),

  updateProblemPR: protectedProcedure
    .input(
      z.object({
        prUrl: z.string().url(),
        problemDetails: z.object({
          title: z.string(),
          slug: z.string(),
          description: z.string(),
          difficulty: z.enum(["EASY", "MEDIUM", "HARD", "EXPERT"]),
          tags: z.array(z.string()),
          referenceCode: z.string(),
          testCases: z.string(),
        }),
      })
    )
    .mutation(async ({ input, ctx }) => {
      if (!ctx.session.user) {
        throw new TRPCError({
          code: "UNAUTHORIZED",
          message: "You must be logged in to update a problem PR",
        });
      }

      try {
        const urlParts = input.prUrl.split("/");
        if (urlParts.length < 7) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Invalid PR URL format",
          });
        }
        const owner = urlParts[3]!;
        const repo = urlParts[4]!;
        const pull_number = parseInt(urlParts[6]!);

        const octokit: Octokit = await getOctokitInstance();
        const { data: pullRequest } = await octokit.pulls.get({
          owner,
          repo,
          pull_number,
        });
        const headBranch: string = pullRequest.head.ref;
        const problemDirPath = `problems/${input.problemDetails.slug}/`;

        // Update problem.md
        await createOrUpdateFile(
          owner,
          repo,
          headBranch,
          `${problemDirPath}problem.md`,
          input.problemDetails.description,
          `fix: Update problem.md for ${input.problemDetails.slug}`
        );

        // Update reference.cu
        await createOrUpdateFile(
          owner,
          repo,
          headBranch,
          `${problemDirPath}reference.cu`,
          input.problemDetails.referenceCode,
          `fix: Update reference.cu for ${input.problemDetails.slug}`
        );

        // Update tests.hpp
        await createOrUpdateFile(
          owner,
          repo,
          headBranch,
          `${problemDirPath}tests.hpp`,
          input.problemDetails.testCases,
          `fix: Update tests.hpp for ${input.problemDetails.slug}`
        );

        // Update metadata.json
        const metadataContent = JSON.stringify(
          {
            title: input.problemDetails.title,
            difficulty: input.problemDetails.difficulty,
            tags: input.problemDetails.tags,
            // tensaraAppUserId is not updated here, it's part of initial submission
          },
          null,
          2
        );
        await createOrUpdateFile(
          owner,
          repo,
          headBranch,
          `${problemDirPath}metadata.json`,
          metadataContent,
          `fix: Update metadata.json for ${input.problemDetails.slug}`
        );

        return { success: true, message: "Problem PR updated successfully" };
      } catch (error) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message:
            error instanceof Error
              ? `Failed to update problem PR: ${error.message}`
              : "Failed to update problem PR",
        });
      }
    }),

  getMyContributions: protectedProcedure.query(async ({ ctx }) => {
    if (!ctx.session.user) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "You must be logged in to view your contributions",
      });
    }

    // Placeholder for getting GitHub username from session/user DB
    // For now, assuming ctx.session.user.name is the GitHub username
    const currentUserGithubUsername = ctx.session.user.name ?? "unknown"; // TODO: Replace with actual GitHub username from user profile

    try {
      const pullRequests = await listPullRequests(
        GITHUB_REPO_OWNER,
        GITHUB_REPO_NAME,
        currentUserGithubUsername,
        "all"
      );

      return pullRequests.map((pr) => ({
        prUrl: pr.html_url,
        title: pr.title,
        status: pr.state,
        createdAt: new Date(pr.created_at),
        updatedAt: new Date(pr.updated_at),
        // You might want to parse the PR body or labels for more details like tensaraAppUserId
      }));
    } catch (error) {
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message:
          error instanceof Error
            ? `Failed to fetch contributions: ${error.message}`
            : "Failed to fetch contributions",
      });
    }
  }),

  getProblemDetails: protectedProcedure
    .input(
      z
        .object({
          slug: z.string().optional(),
          prUrl: z.string().url().optional(),
        })
        .refine((data) => data.slug ?? data.prUrl, {
          message: "Either slug or prUrl must be provided",
        })
    )
    .query(async ({ input, ctx }) => {
      if (!ctx.session.user) {
        throw new TRPCError({
          code: "UNAUTHORIZED",
          message: "You must be logged in to view problem details",
        });
      }

      try {
        const problemContent: {
          problemMd: string | null;
          referenceCu: string | null;
          testsHpp: string | null;
          metadataJson: string | null;
        } = {
          problemMd: null,
          referenceCu: null,
          testsHpp: null,
          metadataJson: null,
        };
        let problemSlug: string; // Ensure problemSlug is always a string
        let branchToFetch: string;
        let owner = GITHUB_REPO_OWNER;
        let repo = GITHUB_REPO_NAME;

        if (input.slug) {
          problemSlug = input.slug;
          branchToFetch = GITHUB_BASE_BRANCH;
        } else if (input.prUrl) {
          const urlParts = input.prUrl.split("/");
          if (urlParts.length < 7) {
            throw new TRPCError({
              code: "BAD_REQUEST",
              message: "Invalid PR URL format",
            });
          }
          owner = urlParts[3]!;
          repo = urlParts[4]!;
          const pull_number = parseInt(urlParts[6]!);

          const octokit = await getOctokitInstance();
          const { data: pullRequest } = await octokit.pulls.get({
            owner,
            repo,
            pull_number,
          });
          branchToFetch = pullRequest.head.ref;

          // Attempt to derive slug from PR title or branch name if not explicitly provided
          const slugMatch = /\(([^)]+)\)$/.exec(pullRequest.title);
          if (slugMatch?.[1]) {
            problemSlug = slugMatch[1];
          } else {
            // Fallback: try to get slug from branch name if it follows the new-problem-{slug}-... pattern
            const branchSlugMatch = /new-problem-([^-]+)-/.exec(branchToFetch);
            if (branchSlugMatch?.[1]) {
              problemSlug = branchSlugMatch[1];
            } else {
              throw new TRPCError({
                code: "BAD_REQUEST",
                message:
                  "Could not determine problem slug from PR URL or title/branch name.",
              });
            }
          }
        } else {
          // This case should ideally be caught by the .refine() in the input schema
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Either slug or prUrl must be provided.",
          });
        }

        const problemDirPath = `problems/${problemSlug}/`;

        problemContent.problemMd = await getFileContent(
          owner,
          repo,
          `${problemDirPath}problem.md`,
          branchToFetch
        );
        problemContent.referenceCu = await getFileContent(
          owner,
          repo,
          `${problemDirPath}reference.cu`,
          branchToFetch
        );
        problemContent.testsHpp = await getFileContent(
          owner,
          repo,
          `${problemDirPath}tests.hpp`,
          branchToFetch
        );
        problemContent.metadataJson = await getFileContent(
          owner,
          repo,
          `${problemDirPath}metadata.json`,
          branchToFetch
        );

        if (!problemContent.problemMd || !problemContent.metadataJson) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Problem details not found.",
          });
        }

        const metadata = ProblemMetadataSchema.parse(
          JSON.parse(problemContent.metadataJson)
        );

        return {
          title: metadata.title,
          slug: problemSlug,
          description: problemContent.problemMd,
          difficulty: metadata.difficulty,
          tags: metadata.tags,
          referenceCode: problemContent.referenceCu,
          testCases: problemContent.testsHpp,
          tensaraAppUserId: metadata.tensaraAppUserId,
        };
      } catch (error) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message:
            error instanceof Error
              ? `Failed to fetch problem details: ${error.message}`
              : "Failed to fetch problem details",
        });
      }
    }),
});
