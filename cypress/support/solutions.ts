export const ReluSolutions = {
  correct: "#include <cuda_runtime.h>\n\n__global__ void matrixReLU(float* input, float* output, size_t rows, size_t cols) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int row_index = idx / cols;\n    int col_index = idx % cols;\n\n    if (row_index < rows && col_index < cols) {\n        int linear_idx = row_index * cols + col_index;\n        output[linear_idx] = (input[linear_idx] > 0) ? input[linear_idx] : 0.0f;\n    }\n\n}\n\nextern \"C\" void solution(float* input, float* output, size_t n, size_t m) {\n    int threadsPerBlock = 256;\n    int blocksPerGrid = (n * m + threadsPerBlock - 1) / threadsPerBlock;\n    matrixReLU<<<blocksPerGrid, threadsPerBlock>>>(input, output, m, n);\n    return;\n    \n}",
  compile_error: "#include <cuda_runtime.h>\n\n__global__ void matrixReLU(float* input, float* output, size_t rows, size_t cols) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int row_index = idx / cols;\n    int col_index = idx % cols;\n\n    if (row_index < rows && col_index < cols) {\n        int linear_idx = row_index * cols + col_index;\n        output[linear_idx] = (input[linear_idx] > 0) ? input[linear_idx] : 0.0f;\n    }\n\n}\n\nextern \"C\" void solution(float* input, float* output, size_t n, size_t m) {\n    int threadsPerBlock = 256;\n    int blocksPerGrid = (n * m + threadsPerBlock - 1) / threadsPerBlock;\n    // Missing angle brackets will cause a compile error\n    matrixReLU(blocksPerGrid, threadsPerBlock)(input, output, m, n);\n    return;\n    \n}",
  runtime_error: "#include <cuda_runtime.h>\n\n__global__ void matrixReLU(float* input, float* output, size_t rows, size_t cols) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    \n    // Will cause division by zero for certain thread indices\n    float test_value = 1.0f / (threadIdx.x % 32);\n    \n    int row_index = idx / cols;\n    int col_index = idx % cols;\n\n    if (row_index < rows && col_index < cols) {\n        int linear_idx = row_index * cols + col_index;\n        // Using potentially infinite value in calculation\n        output[linear_idx] = (input[linear_idx] > 0) ? input[linear_idx] * test_value : 0.0f;\n    }\n\n}\n\nextern \"C\" void solution(float* input, float* output, size_t n, size_t m) {\n     int threadsPerBlock = 256;\n    int blocksPerGrid = (n * m + threadsPerBlock - 1) / threadsPerBlock;\n    matrixReLU<<<blocksPerGrid, threadsPerBlock>>>(input, output, m, n);\n    return;\n    \n}",
  wrong_answer: "#include <cuda_runtime.h>\n\n__global__ void matrixReLU(float* input, float* output, size_t rows, size_t cols) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int row_index = idx / cols;\n    int col_index = idx % cols;\n\n    if (row_index < rows && col_index < cols) {\n        int linear_idx = row_index * cols + col_index;\n        // Incorrect ReLU implementation (negating positive values)\n        output[linear_idx] = (input[linear_idx] > 0) ? 0.0f : input[linear_idx];\n    }\n\n}\n\nextern \"C\" void solution(float* input, float* output, size_t n, size_t m) {\n    int threadsPerBlock = 256;\n    int blocksPerGrid = (n * m + threadsPerBlock - 1) / threadsPerBlock;\n    // Parameters in wrong order\n    matrixReLU<<<blocksPerGrid, threadsPerBlock>>>(input, output, n, m);\n    return;\n    \n}"
}