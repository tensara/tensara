{
  "solution_code": "#include <cuda_runtime.h>\n\n__global__ void vector_add(const float* input1, const float* input2, float* output, size_t n) {\n    const size_t idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        output[idx] = input1[idx] + input2[idx];\n    }\n}\n\nextern \"C\" void solution(const float* d_input1, const float* d_input2, float* d_output, size_t n) {\n    const int block_size = 256;\n    const int num_blocks = (n + block_size - 1) / block_size;\n    vector_add<<<num_blocks, block_size>>>(d_input1, d_input2, d_output, n);\n}",
  "problem": "vector-addition",
  "problem_def": "import torch\nimport ctypes\nfrom typing import List, Dict, Tuple, Any\n\nfrom problem import Problem\n\nclass vector_addition(Problem):\n    \"\"\"Vector addition problem.\"\"\"\n    \n    def __init__(self):\n        super().__init__(\n            name=\"vector-addition\"\n        )\n    \n    def reference_solution(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        PyTorch implementation of vector addition.\n        \n        Args:\n            A: First input tensor\n            B: Second input tensor\n            \n        Returns:\n            Result of A + B\n        \"\"\"\n        with torch.no_grad(), torch.autocast(\"cuda\", enabled=False, dtype=torch.float32):\n            return A + B\n    \n    def generate_test_cases(self, dtype: torch.dtype) -> List[Dict[str, Any]]:\n        \"\"\"\n        Generate test cases for vector addition.\n        \n        Returns:\n            List of test case dictionaries with varying sizes\n        \"\"\"\n        sizes = [\n            (\"n = 2^20\", 1048576),\n            (\"n = 2^22\", 4194304),\n            (\"n = 2^23\", 8388608),\n            (\"n = 2^25\", 33554432),\n            (\"n = 2^26\", 67108864),\n            (\"n = 2^29\", 536870912),\n            (\"n = 2^30\", 1073741824),\n        ]\n        \n        return [\n            {\n                \"name\": name,\n                \"dims\": (size,),\n                \"create_inputs\": lambda size=size: (\n                    torch.rand(size, device=\"cuda\", dtype=dtype) * 2 - 1,  # uniform [-1, 1]\n                    torch.rand(size, device=\"cuda\", dtype=dtype) * 2 - 1   # uniform [-1, 1]\n                )\n            }\n            for name, size in sizes\n        ]\n    \n    def verify_result(self, expected_output: torch.Tensor, \n                     actual_output: torch.Tensor, dtype: torch.dtype) -> Tuple[bool, Dict[str, Any]]:\n        \"\"\"\n        Verify if the vector addition result is correct.\n        \n        Args:\n            expected_output: Output from reference solution\n            actual_output: Output from submitted solution\n            \n        Returns:\n            Tuple of (is_correct, debug_info)\n        \"\"\"\n        is_close = torch.allclose(actual_output, expected_output, rtol=1e-4, atol=1e-3)\n        \n        debug_info = {}\n        if not is_close:\n            diff = actual_output - expected_output\n            max_diff = torch.max(torch.abs(diff)).item()\n            mean_diff = torch.mean(torch.abs(diff)).item()\n            \n            debug_info = {\n                \"max_difference\": max_diff,\n                \"mean_difference\": mean_diff\n            }\n        \n        return is_close, debug_info\n    \n    def get_function_signature(self) -> Dict[str, Any]:\n        \"\"\"\n        Get the function signature for the vector addition solution.\n        \n        Returns:\n            Dictionary with argtypes and restype for ctypes\n        \"\"\"\n        return {\n            \"argtypes\": [\n                ctypes.POINTER(ctypes.c_float),  # input_a\n                ctypes.POINTER(ctypes.c_float),  # input_b\n                ctypes.POINTER(ctypes.c_float),  # output\n                ctypes.c_size_t                  # N\n            ],\n            \"restype\": None\n        }\n    \n    def get_flops(self, test_case: Dict[str, Any]) -> int:\n        \"\"\"\n        Get the number of floating point operations for the problem.\n        \n        Args:\n            test_case: The test case dictionary\n            \n        Returns:\n            Number of floating point operations\n        \"\"\"\n        # Vector addition has 1 FLOP per element\n        N = test_case[\"dims\"][0]\n        return N\n    \n    def get_extra_params(self, test_case: Dict[str, Any]) -> List[Any]:\n        \"\"\"\n        Get extra parameters to pass to the CUDA solution.\n        \n        Args:\n            test_case: The test case dictionary\n            \n        Returns:\n            List containing the vector length N\n        \"\"\"\n        N = test_case[\"dims\"][0]\n        return [N]",
  "gpu": "T4",
  "dtype": "float32",
  "language": "cuda"
}
